/*
 * (c) Copyright 2014-2015 Openflexo
 *
 * This file is part of OpenFlexo.
 *
 * OpenFlexo is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenFlexo is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with OpenFlexo. If not, see <http://www.gnu.org/licenses/>.
 *
 */

Package org.openflexo.foundation.fml.parser;

Helpers
  unicode_input_character = [0..0xffff];
  ht  = 0x0009;
  lf  = 0x000a;
  ff  = 0x000c;
  cr  = 0x000d;
  sp  = ' ';

  line_terminator = lf | cr | cr lf;
  input_character = [unicode_input_character - [cr + lf]];

  not_star =    [input_character - '*'] | line_terminator;
  not_star_not_slash = [input_character - ['*' + '/']] | line_terminator;

  unicode_letter =
    [0x0041..0x005a] | [0x0061..0x007a] | [0x00aa..0x00aa] | [0x00b5..0x00b5] |
    [0x00ba..0x00ba] | [0x00c0..0x00d6] | [0x00d8..0x00f6] | [0x00f8..0x01f5] |
    [0x01fa..0x0217] | [0x0250..0x02a8] | [0x02b0..0x02b8] | [0x02bb..0x02c1] |
    [0x02d0..0x02d1] | [0x02e0..0x02e4] | [0x037a..0x037a] | [0x0386..0x0386] |
    [0x0388..0x038a] | [0x038c..0x038c] | [0x038e..0x03a1] | [0x03a3..0x03ce] |
    [0x03d0..0x03d6] | [0x03da..0x03da] | [0x03dc..0x03dc] | [0x03de..0x03de] |
    [0x03e0..0x03e0] | [0x03e2..0x03f3] | [0x0401..0x040c] | [0x040e..0x044f] |
    [0x0451..0x045c] | [0x045e..0x0481] | [0x0490..0x04c4] | [0x04c7..0x04c8] |
    [0x04cb..0x04cc] | [0x04d0..0x04eb] | [0x04ee..0x04f5] | [0x04f8..0x04f9] |
    [0x0531..0x0556] | [0x0559..0x0559] | [0x0561..0x0587] | [0x05d0..0x05ea] |
    [0x05f0..0x05f2] | [0x0621..0x063a] | [0x0640..0x064a] | [0x0671..0x06b7] |
    [0x06ba..0x06be] | [0x06c0..0x06ce] | [0x06d0..0x06d3] | [0x06d5..0x06d5] |
    [0x06e5..0x06e6] | [0x0905..0x0939] | [0x093d..0x093d] | [0x0958..0x0961] |
    [0x0985..0x098c] | [0x098f..0x0990] | [0x0993..0x09a8] | [0x09aa..0x09b0] |
    [0x09b2..0x09b2] | [0x09b6..0x09b9] | [0x09dc..0x09dd] | [0x09df..0x09e1] |
    [0x09f0..0x09f1] | [0x0a05..0x0a0a] | [0x0a0f..0x0a10] | [0x0a13..0x0a28] |
    [0x0a2a..0x0a30] | [0x0a32..0x0a33] | [0x0a35..0x0a36] | [0x0a38..0x0a39] |
    [0x0a59..0x0a5c] | [0x0a5e..0x0a5e] | [0x0a72..0x0a74] | [0x0a85..0x0a8b] |
    [0x0a8d..0x0a8d] | [0x0a8f..0x0a91] | [0x0a93..0x0aa8] | [0x0aaa..0x0ab0] |
    [0x0ab2..0x0ab3] | [0x0ab5..0x0ab9] | [0x0abd..0x0abd] | [0x0ae0..0x0ae0] |
    [0x0b05..0x0b0c] | [0x0b0f..0x0b10] | [0x0b13..0x0b28] | [0x0b2a..0x0b30] |
    [0x0b32..0x0b33] | [0x0b36..0x0b39] | [0x0b3d..0x0b3d] | [0x0b5c..0x0b5d] |
    [0x0b5f..0x0b61] | [0x0b85..0x0b8a] | [0x0b8e..0x0b90] | [0x0b92..0x0b95] |
    [0x0b99..0x0b9a] | [0x0b9c..0x0b9c] | [0x0b9e..0x0b9f] | [0x0ba3..0x0ba4] |
    [0x0ba8..0x0baa] | [0x0bae..0x0bb5] | [0x0bb7..0x0bb9] | [0x0c05..0x0c0c] |
    [0x0c0e..0x0c10] | [0x0c12..0x0c28] | [0x0c2a..0x0c33] | [0x0c35..0x0c39] |
    [0x0c60..0x0c61] | [0x0c85..0x0c8c] | [0x0c8e..0x0c90] | [0x0c92..0x0ca8] |
    [0x0caa..0x0cb3] | [0x0cb5..0x0cb9] | [0x0cde..0x0cde] | [0x0ce0..0x0ce1] |
    [0x0d05..0x0d0c] | [0x0d0e..0x0d10] | [0x0d12..0x0d28] | [0x0d2a..0x0d39] |
    [0x0d60..0x0d61] | [0x0e01..0x0e2e] | [0x0e30..0x0e30] | [0x0e32..0x0e33] |
    [0x0e40..0x0e46] | [0x0e81..0x0e82] | [0x0e84..0x0e84] | [0x0e87..0x0e88] |
    [0x0e8a..0x0e8a] | [0x0e8d..0x0e8d] | [0x0e94..0x0e97] | [0x0e99..0x0e9f] |
    [0x0ea1..0x0ea3] | [0x0ea5..0x0ea5] | [0x0ea7..0x0ea7] | [0x0eaa..0x0eab] |
    [0x0ead..0x0eae] | [0x0eb0..0x0eb0] | [0x0eb2..0x0eb3] | [0x0ebd..0x0ebd] |
    [0x0ec0..0x0ec4] | [0x0ec6..0x0ec6] | [0x0edc..0x0edd] | [0x0f40..0x0f47] |
    [0x0f49..0x0f69] | [0x10a0..0x10c5] | [0x10d0..0x10f6] | [0x1100..0x1159] |
    [0x115f..0x11a2] | [0x11a8..0x11f9] | [0x1e00..0x1e9b] | [0x1ea0..0x1ef9] |
    [0x1f00..0x1f15] | [0x1f18..0x1f1d] | [0x1f20..0x1f45] | [0x1f48..0x1f4d] |
    [0x1f50..0x1f57] | [0x1f59..0x1f59] | [0x1f5b..0x1f5b] | [0x1f5d..0x1f5d] |
    [0x1f5f..0x1f7d] | [0x1f80..0x1fb4] | [0x1fb6..0x1fbc] | [0x1fbe..0x1fbe] |
    [0x1fc2..0x1fc4] | [0x1fc6..0x1fcc] | [0x1fd0..0x1fd3] | [0x1fd6..0x1fdb] |
    [0x1fe0..0x1fec] | [0x1ff2..0x1ff4] | [0x1ff6..0x1ffc] | [0x207f..0x207f] |
    [0x2102..0x2102] | [0x2107..0x2107] | [0x210a..0x2113] | [0x2115..0x2115] |
    [0x2118..0x211d] | [0x2124..0x2124] | [0x2126..0x2126] | [0x2128..0x2128] |
    [0x212a..0x2131] | [0x2133..0x2138] | [0x3005..0x3005] | [0x3031..0x3035] |
    [0x3041..0x3094] | [0x309b..0x309e] | [0x30a1..0x30fa] | [0x30fc..0x30fe] |
    [0x3105..0x312c] | [0x3131..0x318e] | [0x4e00..0x9fa5] | [0xac00..0xd7a3] |
    [0xf900..0xfa2d] | [0xfb00..0xfb06] | [0xfb13..0xfb17] | [0xfb1f..0xfb28] |
    [0xfb2a..0xfb36] | [0xfb38..0xfb3c] | [0xfb3e..0xfb3e] | [0xfb40..0xfb41] |
    [0xfb43..0xfb44] | [0xfb46..0xfbb1] | [0xfbd3..0xfd3d] | [0xfd50..0xfd8f] |
    [0xfd92..0xfdc7] | [0xfdf0..0xfdfb] | [0xfe70..0xfe72] | [0xfe74..0xfe74] |
    [0xfe76..0xfefc] | [0xff21..0xff3a] | [0xff41..0xff5a] | [0xff66..0xffbe] |
    [0xffc2..0xffc7] | [0xffca..0xffcf] | [0xffd2..0xffd7] | [0xffda..0xffdc];

  unicode_digit =
    [0x0030..0x0039] | [0x0660..0x0669] | [0x06f0..0x06f9] | [0x0966..0x096f] |
    [0x09e6..0x09ef] | [0x0a66..0x0a6f] | [0x0ae6..0x0aef] | [0x0b66..0x0b6f] |
    [0x0be7..0x0bef] | [0x0c66..0x0c6f] | [0x0ce6..0x0cef] | [0x0d66..0x0d6f] |
    [0x0e50..0x0e59] | [0x0ed0..0x0ed9] | [0x0f20..0x0f29] | [0xff10..0xff19];

  java_letter = unicode_letter | '$' | '_';
  java_letter_or_digit = unicode_letter | unicode_digit | '$' | '_';

  uri_letter_or_digit = unicode_letter | unicode_digit | '$' | '_' | '.' | '/';

  non_zero_digit = ['1'..'9'];
  digit = ['0'..'9'];
  hex_digit = ['0'..'9'] | ['a'..'f'] | ['A'..'F'];
  octal_digit = ['0'..'7'];
  zero_to_three = ['0'..'3'];

  decimal_numeral = '0' | non_zero_digit digit*;
  hex_numeral = '0' ('x' | 'X') hex_digit+;
  octal_numeral = '0' octal_digit+;

  integer_type_suffix = 'l' | 'L';

  exponent_part = ('e' | 'E') ('+' | '-')? digit+;

  float_type_suffix = 'f' | 'F' | 'd' | 'D';

  single_character = [input_character - [''' + '\']];
  octal_escape = '\' (octal_digit octal_digit? | zero_to_three octal_digit octal_digit);
  escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\' | octal_escape;
  string_character = [input_character - ['"' + '\']] | escape_sequence;

  upper_case = ['A' .. 'Z'] | [0x00c0 .. 0x00dd] | 0x20ac;
  lower_case = ['a' .. 'z'] | [0x00e0 .. 0x00fd] | 0x20ac;
  letter = upper_case | lower_case | '_' | '@';
  any        = [0 .. 0xffff];
  not_hyphen = [any - '"' ];
  not_hyphen2 = [any - ''' ];
  file_char = upper_case | lower_case | digit | '_' | '.';
  uri_char = upper_case | lower_case | digit | '_' | '.' | '/';

Tokens

  // separators

  at = '@';
  comma = ',';
  dot   = '.';
  dot_dot_dot = '...';
  l_bkt = '[';
  l_brc = '{';
  l_par = '(';
  r_bkt = ']';
  r_brc = '}';
  r_par = ')';
  semi  = ';';

  // operators

  amp = '&';
  amp_amp = '&&';
  amp_assign = '&=';
  assign = '=';
  bar = '|';
  bar_assign = '|=';
  bar_bar = '||';
  caret = '^';
  caret_assign = '^=';
  colon = ':';
  dollar = '$';
  emark = '!';
  eq = '==';
  gt = '>';
  gteq = '>=';
  lt = '<';
  lteq = '<=';
  minus = '-';
  minus_assign = '-=';
  minus_minus = '--';
  neq = '!=';
  percent = '%';
  percent_assign = '%=';
  plus = '+';
  plus_assign = '+=';
  plus_plus = '++';
  qmark = '?';
  //shl = '<<';
  //shl_assign = '<<=';
  //shr = '>>';
  //shr_assign = '>>=';
  slash = '/';
  slash_assign = '/=';
  star = '*';
  star_assign = '*=';
  tilde = '~';
  //ushr = '>>>';
  //ushr_assign = '>>>=';
  if_token = '?';
  else_token = ':';
  

  // keywords

  abstract = 'abstract';
  assert = 'assert';
  boolean = 'boolean';
  break = 'break';
  byte = 'byte';
  case = 'case';
  catch = 'catch';
  char = 'char';
  const = 'const';
  continue = 'continue';
  default = 'default';
  do = 'do';
  double = 'double';
  else = 'else';
  enum = 'enum';
  extends = 'extends';
  false = 'false';
  final = 'final';
  finally_token = 'finally';
  float = 'float';
  for = 'for';
  if = 'if';
  instanceof = 'instanceof';
  int = 'int';
  long = 'long';
  new = 'new';
  package = 'package';
  private = 'private';
  protected = 'protected';
  public = 'public';
  return = 'return';
  short = 'short';
  static = 'static';
  switch = 'switch';
  this = 'this';
  throw = 'throw';
  throws_token = 'throws';
  true = 'true';
  try = 'try';
  void = 'void';
  while = 'while';
  
  // FML keywords
  virtual_model = 'VirtualModel';
  use = 'use';
  as = 'as';
  import = 'import';   
  flexo_concept = 'FlexoConcept';   
  fml_expression = 'FML::Expression';   
  fml_get_set = 'FML::GetSet';   
  one = 'one';   
  maybe = 'maybe';   
  many = 'many';   
  some = 'some'; 
 
  // literals

  character_literal = ''' (single_character | escape_sequence) ''';

  floating_point_literal =
    digit+ '.' digit* exponent_part? float_type_suffix? |
    '.' digit+ exponent_part? float_type_suffix? |
    digit+ exponent_part float_type_suffix? |
    digit+ exponent_part? float_type_suffix;

  integer_literal =
    decimal_numeral integer_type_suffix? |
    hex_numeral integer_type_suffix? |
    octal_numeral integer_type_suffix?;

  null_literal = 'null';

  string_literal = '"' string_character* '"';

   // Math
   
  pi = 'pi';
  cos = 'cos';
  acos = 'acos';
  sin = 'sin';
  asin = 'asin';
  tan = 'tan';
  atan = 'atan';
  log = 'log';
  exp = 'exp';
  sqrt = 'sqrt';

   // identifier

  identifier = java_letter java_letter_or_digit*;

  // white space and comments

  white_space = (sp | ht | ff | line_terminator)*;

  traditional_comment = '/*' not_star+ '*'+ (not_star_not_slash not_star* '*'+)* '/';
  documentation_comment =    '/**' '*'* (not_star_not_slash not_star* '*'+)* '/';
  end_of_line_comment = '//' input_character* line_terminator?;

  //uri = '[http://' unicode_letter (uri_letter_or_digit)* ']';
  static_uri = '[' '"' string_character* '"' ']';
  ta_identifier = (java_letter*) '::' (java_letter*);
 
Ignored Tokens
  white_space,
  traditional_comment,
  documentation_comment,
  end_of_line_comment;
 
Productions

  compilation_unit = [use_declarations]:use_declaration* [import_declarations]:import_declaration* virtual_model_declaration;

  use_declaration = use [technology_adapter]:dot_identifier as [ta_id]:identifier semi;

  import_declaration = 
   	{java_import_declaration} java_import_declaration |
  	{resource_import_declaration} resource_import_declaration;

  resource_import_declaration = 
  	import uri as dot_identifier semi;

  java_import_declaration = 
  	{simple} import dot_identifier semi /* |
  	{wilcard} import dot_identifier dot star semi*/;

  virtual_model_declaration = [annotations]:annotation* visibility? static? virtual_model identifier super? l_brc [concept_body_declarations]:concept_body_declaration* r_brc;

  flexo_concept_declaration = [annotations]:annotation* visibility? static? flexo_concept identifier super? l_brc [concept_body_declarations]:concept_body_declaration* r_brc;

  concept_body_declaration =
    {property} property_declaration |
    {flexo_behaviour_declaration} flexo_behaviour_declaration |
    {flexo_concept} flexo_concept_declaration;

  super =
    extends super_type_list;

  super_type_list =
    {one} dot_identifier |
    {many} super_type_list comma dot_identifier;

  visibility =
    {private}      private |
    {protected}    protected |
    {public}       public;
  
  // Annotations
  
  annotation =
    {normal_annotation}         normal_annotation |
    {marker_annotation}         marker_annotation |
    {single_element_annotation} single_element_annotation;

  normal_annotation =
    at dot_identifier l_par element_value_pairs? r_par;

  marker_annotation =
    at dot_identifier;

  single_element_annotation =
    at dot_identifier l_par expression r_par;

  element_value_pair =
    identifier assign expression;

  element_value_pairs =
    {one} element_value_pair |
    {many} element_value_pairs comma element_value_pair;

  // FML elements

  fml_element_configuration =
    l_par element_value_pairs? r_par;
 
  // Properties
 
  property_declaration =
    {primitive_role_declaration} primitive_role_declaration |
    {expression_property_declaration} expression_property_declaration |
    {role_declaration} role_declaration;
 
  primitive_role_declaration =
    {primitive} [annotations]:annotation* visibility? cardinality? primitive_type identifier semi |
    {java_role_declaration} java_role_declaration ;
  
  java_role_declaration =
    [annotations]:annotation* visibility? /*cardinality?*/ type identifier semi;
  
  role_declaration =
    [annotations]:annotation* visibility? cardinality? ta_identifier lt dot_identifier gt identifier fml_element_configuration? semi;
 
  cardinality =
    {one}   one |
    {maybe} maybe |
    {many}  many |
    {some}  some;
  
  expression_property_declaration =
    [annotations]:annotation* visibility? fml_expression lt type gt identifier assign expression semi;
 
  // Behaviours
  
  flexo_behaviour_declaration = 
    {default} [annotations]:annotation* visibility? behaviour_return_type? [behaviour_category]:identifier colon flexo_behaviour_arguments_declaration? flexo_behaviour_body |
    {named} [annotations]:annotation* visibility? behaviour_return_type? [behaviour_category]:identifier colon [behaviour_name]:identifier flexo_behaviour_arguments_declaration? flexo_behaviour_body;  
 
  flexo_behaviour_arguments_declaration =
    l_par formal_arguments_list? r_par;
    
  formal_arguments_list =
    {one} formal_argument |
    {many} formal_arguments_list comma formal_argument;
  
  formal_argument =
  	type identifier;
 
  flexo_behaviour_body =
    {block} block |
    {empty} semi;
 
  behaviour_return_type =
    {void} void |
    {type} type;
  
 
  // Types
  
  type =
    {primitive} primitive_type |
    {java_class} dot_identifier |
    {parameterized_type} dot_identifier type_arguments |
    {ta_type} ta_type;

  ta_type =
    {primitive} ta_identifier lt primitive_type gt |
    {identifier} ta_identifier lt dot_identifier gt;
    
  primitive_type =
    {numeric} numeric_type |
    {boolean} boolean;
  
  numeric_type =
    {integral} integral_type |
    {floating} floating_point_type;
  
   integral_type =
    {byte}  byte |
    {short} short |
    {int}   int |
    {long}  long |
    {char}  char;

  floating_point_type =
    {float}  float |
    {double} double;
 
  type_arguments =
    lt type_argument_list gt;
 
  actual_type_argument =
    {primitive} primitive_type |
    {reference} dot_identifier type_arguments? /* |
    {wildcard}  wildcard*/;
 
  type_argument_list =
    {one}                                  actual_type_argument |
    {many} type_argument_list comma actual_type_argument;

  // Literals
  
  literal =
    {integer}        integer_literal |
    {floating_point} floating_point_literal |
    {boolean}        boolean_literal |
    {character}      character_literal |
    {string}         string_literal |
    {null}           null_literal |
    {uri}            uri;

  // Encodes a URI, under the forms:
  // - ["http://anUri"]
  // - [NameSpace]
  // - [NameSpace:"aString"]
  // - [NameSpace:"aString":"anOtherString"]
  uri =
    {static_uri} static_uri |
    {uri} l_bkt dot_identifier uri_suffix_list? r_bkt;

  uri_suffix_list =
    {string_literal} colon string_literal |
    {uri_suffix_list} colon string_literal uri_suffix_list;
  
  boolean_literal =
    {true}  true |
    {false} false;

  // Expressions

  assignation_expression = 
    {eq_expr} [left]:dot_identifier assign [right]:expression;
    
  expression =
    {expr2} expr2 |
    {cond_expr} [condition]:expression if_token [then]:expr2 else_token [else]:expr2 |
    {eq_expr} [left]:expr2 eq [right]:expr2 |
    {neq_expr} [left]:expr2 neq [right]:expr2 |
    {lt_expr} [left]:expr2 lt [right]:expr2 |
    {gt_expr} [left]:expr2 gt [right]:expr2 |
    {lte_expr} [left]:expr2 lteq [right]:expr2 |
    {gte_expr} [left]:expr2 gteq [right]:expr2 ;

  expr2 =
    {expr3} expr3 |
    {or_expr} [left]:expr2 bar [right]:expr3 |
    {or2_expr} [left]:expr2 bar_bar [right]:expr3 |
    {add_expr} [left]:expr2 plus [right]:expr3 |
    {sub_expr} [left]:expr2 minus [right]:expr3;
  
  expr3 =
    {term} term |
    {and_expr} [left]:expr3 amp [right]:term |
    {and2_expr} [left]:expr3 amp_amp [right]:term |
    {mult_expr} [left]:expr3 star [right]:term |
    {div_expr} [left]:expr3 slash [right]:term |
    {mod_expr} [left]:expr3 percent [right]:term |
    {power_expr} [left]:expr3 caret [right]:term |
    {not_expr} emark term;

  type_reference = 
    {basic} dollar type_reference_path |
    {parametered} dollar type_reference_path type_reference_arg_list;

  type_reference_path = 
    {identifier} identifier |
    {tail} identifier dot type_reference_path;

  type_reference_arg_list = 
    lt type_reference [type_reference_additional_args]:type_reference_additional_arg* gt;

  type_reference_additional_arg = 
    comma type_reference;

  call = 
    dot_identifier arg_list ;

  arg_list = 
    {empty_list} l_par r_par |
    {non_empty_list} l_par expression [additional_args]:additional_arg* r_par;

  additional_arg = 
    comma expression;

  dot_identifier =
    {identifier} allowed_identifier_in_binding |
    {tail} allowed_identifier_in_binding dot dot_identifier;

  allowed_identifier_in_binding =
    {identifier} identifier |
    {many} many |
    {one} one |
    {this} this;

  binding = 
    {dot_identifier} dot_identifier |
    {call} call |
    {tail} call dot binding;

  function =
    {cos_func} cos l_par expr2 r_par |
    {acos_func} acos l_par expr2 r_par |
    {sin_func} sin l_par expr2 r_par |
    {asin_func} asin l_par expr2 r_par |
    {tan_func} tan l_par expr2 r_par |
    {atan_func} atan l_par expr2 r_par |
    {exp_func} exp l_par expr2 r_par |
    {log_func} log l_par expr2 r_par |
    {sqrt_func} sqrt l_par expr2 r_par;

  term =
    {negative} minus term |
    {literal} literal |
    {function} function |
    {binding} binding |
    {ta_data} ta_identifier lt dot_identifier gt fml_element_configuration? |
    {expr} l_par expression r_par |
    {cast} l_par type_reference r_par term;
 
  // Statements

  behaviour_body =
    {block} block |
    {empty} semi;
  
  block =
    l_brc [block_statements]:block_statement* r_brc;

  block_statement =
    {variable_declaration} local_variable_declaration_statement |
    {statement}            statement;

  local_variable_declaration_statement =
    local_variable_declaration semi;

  local_variable_declaration =
    type variable_declarator;

  variable_declarator =
    {simple}      identifier |
    {initializer} identifier assign expression;

  statement =
    {no_trail}   statement_without_trailing_substatement |
    {if}         if_then_statement |
    {if_else}    if_then_else_statement |
    {while_loop} while_statement |
    {for_loop}   for_statement;

  statement_without_trailing_substatement =
    {block}                  block |
    {empty_statement}        empty_statement |
    {expression_statement}   expression_statement |
    {return_statement}       return_statement;

  empty_statement =
    semi;

  expression_statement =
    statement_expression semi;
 
  statement_expression =
    {assignment} assignation_expression |
    {expression} expr2 |
    {ta_edition_action_expression} ta_edition_action_expression /*|
    {instance_creation} class_instance_creation_expression*/;

  ta_edition_action_expression =
    {unqualified} ta_identifier arg_list |
    {qualified} ta_identifier qualified_arg_list;

  qualified_arg_list = 
    {empty_list} l_par r_par |
    {non_empty_list} l_par assignation_expression [additional_args]:qualified_additional_arg* r_par;

  qualified_additional_arg = 
    comma assignation_expression;

  return_statement =
    {empty}      return semi |
    {expression} return expression semi;

  if_then_statement =
    if l_par expression r_par statement;

  if_then_else_statement =
    if l_par expression r_par statement_no_short_if else statement;

  statement_no_short_if =
    {statement_without_trailing_substatement} statement_without_trailing_substatement |
    {if_then_else_statement_no_short_if}      if_then_else_statement_no_short_if |
    {while_statement_no_short_if}             while_statement_no_short_if |
    {for_statement_no_short_if}               for_statement_no_short_if;

  if_then_else_statement_no_short_if =
    if l_par expression r_par [statement_no_short_if1]:statement_no_short_if else [statement_no_short_if2]:statement_no_short_if;

  while_statement_no_short_if =
    while l_par expression r_par statement_no_short_if;

  for_statement_no_short_if =
    {empty}      for l_par for_init? [semi1]:semi [semi2]:semi for_update? r_par statement_no_short_if |
    {expression} for l_par for_init? [semi1]:semi expression [semi2]:semi for_update? r_par statement_no_short_if;

  for_init =
    {statement} statement_expression |
    {variable_declaration} local_variable_declaration;

  for_update =
    statement_expression;

  while_statement =
    while l_par expression r_par statement;

  for_statement =
    {basic_for}    basic_for_statement |
    {enhanced_for} enhanced_for_statement;
  
  basic_for_statement =
    {empty}      for l_par for_init? [semi1]:semi [semi2]:semi for_update? r_par statement |
    {expression} for l_par for_init? [semi1]:semi expression [semi2]:semi for_update? r_par statement;

  enhanced_for_statement =
    for l_par type identifier colon expression r_par statement;

  